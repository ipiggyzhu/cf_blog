---
date: 2025-09-28 02:10:47
title: Shell脚本集合
article: false
top: false
categories:
  - 专题
tags:
  - Shell
  - Linux
  - 自动?
coverImg: /img/nav/脚本.svg
permalink: /zhuanti/shell-scripts
homeCardSort:
description: Shell脚本是Linux/Unix系统管理员的利器，让繁琐的运维工作自动化
---

# 🐚 Shell脚本集合

> 💡 Shell脚本是Linux/Unix系统管理员的利器，让繁琐的运维工作自动化

---

## 🔧 系统监控脚本

### 🖥?服务器性能监控

实时监控CPU、内存、磁盘使用率，超出阈值自动告?

```bash
#!/bin/bash
# 性能监控脚本
CPU_THRESHOLD=80
MEM_THRESHOLD=85

cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
mem_usage=$(free | grep Mem | awk '{printf("%.2f", $3/$2 * 100.0)}')

if (( $(echo "$cpu_usage > $CPU_THRESHOLD" | bc -l) )); then
    echo "警告: CPU使用率过?($cpu_usage%)"
fi
```

**标签?* 📅 2024-03-20 | ?高频使用 | 🔄 自动告警

---

### 📊 系统状态检?

全面检查系统状态，包括服务、端口、磁盘空间等

```bash
#!/bin/bash
# 系统状态检查脚?
echo "=== 系统状态检查报?==="
echo "时间: $(date)"
echo "主机? $(hostname)"
echo "运行时间: $(uptime)"
echo "磁盘使用情况:"
df -h | grep -E '^/dev/'
echo "内存使用情况:"
free -h
```

**标签?* 📅 2024-03-15 | ?常用工具 | 📋 状态报?

---

## 🗂?文件管理脚本

### 🗄?日志清理

自动清理指定天数前的日志文件，释放磁盘空?

```bash
#!/bin/bash
# 日志清理脚本
LOG_DIR="/var/log"
DAYS=30

echo "清理 $DAYS 天前的日志文?.."
find $LOG_DIR -name "*.log" -type f -mtime +$DAYS -exec rm -f {} \;
find $LOG_DIR -name "*.log.*" -type f -mtime +$DAYS -exec rm -f {} \;
echo "日志清理完成"
```

**标签?* 📅 2024-03-10 | ?定时任务 | 🧹 空间清理

---

### 💾 文件备份

增量备份重要文件到远程服务器，支持压缩和加密

```bash
#!/bin/bash
# 文件备份脚本
SOURCE_DIR="/home/data"
BACKUP_DIR="/backup"
DATE=$(date +%Y%m%d_%H%M%S)

tar -czf "$BACKUP_DIR/backup_$DATE.tar.gz" "$SOURCE_DIR"
echo "备份完成: backup_$DATE.tar.gz"

# 同步到远程服务器
rsync -avz "$BACKUP_DIR/" user@remote:/backup/
```

**标签?* 📅 2024-03-05 | ?数据安全 | 🔄 增量备份

---

## 🚀 服务管理脚本

### ⚙️ 服务监控重启

监控关键服务状态，自动重启异常服务

```bash
#!/bin/bash
# 服务监控脚本
SERVICES=("nginx" "mysql" "redis")

for service in "${SERVICES[@]}"; do
    if ! systemctl is-active --quiet $service; then
        echo "服务 $service 已停止，正在重启..."
        systemctl restart $service
        sleep 5
        if systemctl is-active --quiet $service; then
            echo "服务 $service 重启成功"
        else
            echo "服务 $service 重启失败，请手动检?
        fi
    fi
done
```

**标签?* 📅 2024-03-18 | ?高可?| 🔄 自动恢复

---

## 🌐 网络工具脚本

### 🔍 端口扫描

扫描指定主机的开放端口，检查服务可用?

```bash
#!/bin/bash
# 端口扫描脚本
HOST=$1
PORTS=(22 80 443 3306 6379)

if [ -z "$HOST" ]; then
    echo "用法: $0 <主机地址>"
    exit 1
fi

echo "扫描主机: $HOST"
for port in "${PORTS[@]}"; do
    if timeout 3 bash -c "echo >/dev/tcp/$HOST/$port" 2>/dev/null; then
        echo "端口 $port: 开?
    else
        echo "端口 $port: 关闭"
    fi
done
```

**标签?* 📅 2024-03-12 | ?网络诊断 | 🔍 安全检?

---

## 📈 Shell脚本统计

| 指标 | 数?|
|------|------|
| 脚本总数 | 15+ |
| 分类数量 | 4?|
| 更新频率 | 周更?|
| 使用场景 | 运维自动?|

---

## 💡 Shell编程技?

### 🔧 变量与参?
- 使用 `${var}` 进行变量引用
- 检查参数数? `if [ $# -ne 2 ]`
- 设置默认? `${var:-default}`

### 🛡?错误处理
- 使用 `set -e` 遇错即停
- 检查命令执行结? `if [ $? -eq 0 ]`
- 日志记录: `echo "错误信息" >> error.log`

### ?性能优化
- 避免频繁调用外部命令
- 使用内置命令替代外部工具
- 合理使用管道和重定向

---

> 🛠?好的Shell脚本不仅能解决问题，更应该具备可读性、可维护性和健壮?
